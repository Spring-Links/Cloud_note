**mysql有哪些存储引擎，默认存储引擎是什么**
- 存储引擎：InnoDB、MyISAM、MEMORY
- 默认存储引擎：InnoDB

**什么是索引，有什么作用**
- 索引：它是一种数据结构，该结构指向数据库中的数据，使数据库引擎能够快速定位到特定的数据行，而无需扫描整个表
- 作用：可以使查询操作更加高效的进行，在唯一索引中还能保证数据的唯一性，避免重复数据

**一张表中应该有多少条索引，什么情况下不应该添加索引**
- 索引条数：一张表中的索引条数并没有定论，而是根据实际情况选择该列是否要添加索引
- 何种情况不添加索引：
    1. 频繁更新的列：当一列数据经常进行更新时，索引也会跟着更新进行输入输出操作，从而浪费性能和磁盘空间
    2. 单调的列：如当该列数据仅包含男女信息时，因为对查询有效信息没有实质性帮助，所以也不推荐
    3. 数据量小的表：当数据量小时直接查找表更合适

**尝试为之前的表添加10万条数据**
**查询年龄最大的10个人，记录查询时间，之后为生日字段添加索引，再次查询，对比在索引的影响下快了多长时间**
- 无索引：
```
select birth from information order by birth limit 10
> OK
> 查询时间: 0.032s
```
- 有索引：
```
select birth from information order by birth limit 10
> OK
> 查询时间: 0.000s
```
**什么是事务，事务有哪些特性**
- 事务：它是数据库管理系统执行过程中的一个逻辑单元，包含一组操作，要么全部执行成功提交，要么全部不执行回滚。确保数据的一致性、完整性。
- 特性：
    - 原子性：事务是一个不可分割的单元，操作要么全部成功执行，要么失败回滚
    - 一致性：数据库从一个一致状态转移到另一个一致状态
    - 隔离性：多个事务之间相互隔离，一个事务的中间状态不会被其他事务看到
    - 持久性：一旦事务提交，修改的内容就会永久保存到数据库

**事务如何标记开始、执行、回滚**
- 开始：start transaction;begin
- 提交：commit
- 回滚：rollback

**什么是数据一致性，在关系型数据库中数据一致性是否重要**
- 数据一致性：多个用户在任何给定时间内拿到的数据都是准确可靠的，当一个事物对数据库进行操作时，它必须将数据库从一个一致性状态，转换到另一个一致性状态
- 重要性：它能保证数据的准确性和完整性

**什么是锁，是为了解决什么问题，达到什么效果**
- 锁：保证在一段时间内数据的一致性
- 作用：能够保障数据的正确性，在高并发时能保护数据的一致性

**什么是表锁、意向锁、行锁、共享锁、排他锁**
|表级锁|别名|语法|描述|
|:-:|:-:|:-:|:-:|
|表共享锁|读锁|加锁：`lock tables table_name read;`<br>释放：`unlock tables;`|自己和他人能读不能写|
|表独占锁|写锁|加锁：`lock tables table_name write;`<br>释放：`unlock tables;`|自己能读能写，他人不能读写|
|意向共享锁|IS|加锁：由`select...lock in share mode`添加|与表锁共享锁兼容，与表锁排他锁互斥|
|意向排他锁|IX|加锁：由`insert、update、delete、select...for update`添加|与表锁共享锁都互斥，意向锁之间不互斥|

|行级锁|别名|语法|描述|
|:-:|:-:|:-:|:-:|
|共享锁|S|加锁：`select...lock in share mode(手动添加)`|允许事务去读一行，阻止其他事务获取相同的数据集的排他锁|
|排他锁|X|加锁：`insert、update、delete(自动加锁)`<br>`select...for update(手动添加)`|允许获取排他锁的事务更新数据，阻止其他事务获取相同的数据集的共享锁和排他锁|

==注意select...不会加任何锁==

**什么是悲观锁、乐观锁、**

|类型|场景|用法|
|:-:|:-:|:-:|
|乐观锁|数据并发修改的冲突较低<br>读操作远多于写操作<br>事务的执行时间短|如：`update employee set name='tom', version=version + 1 where id=1 and version=0;`|
|悲观锁|写操作较多<br>并发冲突高<br>数据要求强一致性<br>|`select...for update`<br>`select...lock in share mode`|

**什么是死锁，死锁出现需要满足什么条件，出现后应该如何处理，如何预防**
- 死锁：当两个或多个事务在同一时间持有对方需要的资源而不释放自己持有的资源从而陷入循环等待的现象
- 形成条件：
  - 互斥：一个资源只能由一个线程使用，如果一个资源被一个线程持有，其他要访问该资源的线程必须等待，直到资源被释放
  - 持有并等待：一个线程持有了一个资源，还在等待其他线程释放资源
  - 不可抢占：资源只能由线程释放，不能抢夺
  - 循环等待：线程A、B各持有对方需要的资源又不释放，导致陷入循环等待
- 处理方法：
- 预防：
  - 保持事务简短，减少事务持有锁的时间，降低发生冲突的风险
  - 设置锁等待超时时间，当事务等待锁超过一定时间自动放弃锁请求
  - 在不影响数据一致性的情况下调整隔离级别
  - 在发生死锁时查看死锁日志，分析原因，优化设计

**什么是隐式加锁、显式加锁，显式加锁有什么注意事项**
- 隐式加锁：在执行如 `insert、update、delete`等`操作时由系统自己添加锁的方式被称为隐式加锁
- 显示加锁：在执行如 `select...lock in share mode`、`select...for update`等操作时由用户添加锁的方式被称为显示加锁
    - 注意事项：在自己添加锁时应该考虑锁对性能的消耗和死锁等问题

**如果没有锁会出现什么问题，什么是脏读、幻读、不可重复读、丢失更新**
- 没有锁机制：没有锁机制就无法保证数据的一致性，从而导致数据不再具有可靠性
- 脏读：一个事务读取到了另一个事务尚未提交的数据
- 幻读：一个事务在两次查询条件相同时查询到了新数据，该数据可能来自另一个事务在两次查询中间提交的，又恰好符合查询条件的情况
- 不可重复读：事务A在读取一个记录后，事务B就对该记录进行了更改，导致事务A再次读取记录时记录不一致的现象
- 丢失更新：在缺乏锁机制时，两个事务同时对一条记录进行更改，最终导致一个事务覆盖了另一个事务的更改记录

**事务的4个隔离级别是什么，每个隔离级别能防止哪些并发问题**
- 读未提交（Read Uncommitted）：可能存在脏读、不可重复读和幻读
- 读已操作（Read Committed）：存在不可重复读和幻读
- 可重复读（Repeatable Read）：通过临键锁能防止幻读
- 可串行化（Serializable）：事务按照顺序一个一个执行避免了所有问题

**如何查看当前数据库的锁等待和死锁信息**
- 锁等待：
`SELECT * FROM performance_schema.data_locks;`
`SELECT * FROM performance_schema.data_lock_waits;`
- 死锁日志：
`SHOW VARIABLES LIKE 'log_error';`
`SHOW ENGINE INNODB STATUS;`