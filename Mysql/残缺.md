`mysqldump --single-transaction -u root -p 数据库名 > 路径/备份名.sql`

|类型|粒度|场景|语法|特点||
|:-:|:-:|:-:|:-|:-|:-:|
|全局锁|对数据进行备份|能读不能写|加锁：`flush tables with read lock;`<br>释放：`unlock tables;`|1.备份期间业务停摆<br>2.在从库备份会导致不能及时执行主库同步过来的二进制文件，导致主从延迟<br>3.在innodb中可以使用`--single-transaction`参数完成不加锁的一致性数据备份||


表锁：lock tables 表名 read/write
unlock tables
表共享读锁（读锁）自己和他人能读不能写
表独占写锁（写锁）自己能读能写，他人不能读不能写

元数据锁（meta data lock MDL）
系统自动添加
为了避免DML和DDL冲突，保证读写的正确性，当对表进行增删改查时加MDL读锁（共享锁），对表结构更改时加MDL写锁(排他锁)

意向锁 为了避免DML在执行时价格行锁与表锁冲突，加入意向锁后使表锁不用检查每行数据是否加锁，使用意向锁减少对表锁的检查
意向共享锁（IS）：由select...lock in share mode添加
兼容：与表锁共享锁兼容，与表锁排他锁互斥
意向排他锁（IX）：由insert、update、delete、select...for update添加
兼容：与表锁共享锁及排他锁都互斥，意向锁之间不会互斥




行级锁
行锁：锁定具体的某一行的数据RC、RR
共享锁（S）：允许一个事务去读一行，阻止其他事务获取相同数据集
排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获取相同的数据集的共享锁和排他锁

间隙锁：锁定索引记录间隙而不锁定数据，确保索引间隙不变，防止其他事务在该间隙下进行insert，产生幻读RC、RR

临键锁：行锁和间隙锁的组合，锁定数据和数据前面的间隙RR


乐观锁：假设在多个事务同时访问同一条数据时，冲突发生的概率很低，因此操作数据时不会立即锁定，而是在提交数据更改时检查是否有其他事务对该数据进行了更改，如果没有就提交，如果有就回滚
场景：
数据并发修改的冲突较低
读操作远多于写操作
事务的执行时间短
用法：
如：update employee set name='tom', version=version + 1 where id=1 and version=0;

悲观锁：假设数据在并发处理过程中很可能发生冲突，为了保证数据的完整性和一致性，每次读写数据时都会先加锁，这样可以避免其他事务进行并发读写操作
场景：
写操作较多<br>
并发冲突高<br>
数据要求强一致性<br>
用法：
select...for update
select...lock in share mode


|类型|场景|用法|
|:-:|:-:|:-:|
|乐观锁|数据并发修改的冲突较低<br>读操作远多于写操作<br>事务的执行时间短|如：`update employee set name='tom', version=version + 1 where id=1 and version=0;`|
|悲观锁|写操作较多<br>并发冲突高<br>数据要求强一致性<br>|`select...for update`<br>`select...lock in share mode`|







    - **日志文件：** 重做日志（redo log）、撤销日志（undo log）、二进制日志（binlog）
        **重做日志：** 记录事务更改，确保系统崩溃后也能恢复未提交的事务，故障恢复时，可以将已提交但未保存的事务再次保存
        **撤销日志：** 记录事务操作前的数据，以便回滚时恢复到原始状态，故障恢复时可以使用undo log回滚未提交的事务，确保数据的一致性
        **二进制日志：** 记录数据库中所有的更改操作（DDL、DML），用于数据的复制和恢复，用于主从方案
    - **表空间：** 将数据库中的表、索引等对象组织在一起，提供逻辑上的分隔和管理