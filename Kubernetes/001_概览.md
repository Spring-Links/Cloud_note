**容器化部署**
- **优点**
  - 保证每个容器有自己的文件系统、CPU、内存、进程空间
  - 运行应用程序所需要的资源都被容器包装并和底层基础框架解耦
  - 容器化的应用程序可以跨云服务、Linux操作系统发行版进行部署
- **缺点（容器编排问题）**
  - 一个容器发生故障，无法即时替补该容器
  - 大量并发访问是，无法即时横向扩展容器数量



**K8S：** 本质是一组服务器集群，它在集群的每个节点上运行特定程序，对节点中的容器
进行管理实现资源的自动化
- **自我修复：** 一个容器崩溃，他能在1s只有时间启动新的容器
- **弹性伸缩：** 可以根据需要自动对集群中运行的容器进行数量上的调整
- **服务发现：** 服务可以通过自我发现的形式找到它所依赖的服务
- **负载均衡：** 如果一个服务启动了多个容器，能够自动实现负载均衡
- **版本回退：** 如果发现新发布的程序版本有问题，能够立即回退到原来的版本
- **存储编排：** 可以根据容器自身需求主动创建存储卷

****

**k8s概念**
- **Master：** 集群控制节点，每个集群至少需要一个master节点负责集群的管控
- **Node：** 工作负载节点，由master分配容器到node节点，由node节点中的docker负责容器的运行
- **Pod：** k8s中最小的控制单元，容器运行在pod中，一个pod可以有一个或多个容器
- **Controller：** 控制器，通过它实现对pod的管理里，如启动、停止pod或伸缩pod的数量等
- **Service：** pod对外服务的统一接口，下面可以维护同一类的多个pod
- **Label：** 标签，用于对pod进行分类，同一类pod拥有相同的标签
- **NameSpace：** 命名空间，用来隔离pod的运行环境

****

**K8S组件：** 一个K8S集群主要由控制节点工作节点构成，每个节点上都会安装不同的组件
- **master(控制节点)：** 集群控制层面，负责集群决策管理
  - `ApiServer`资源操作的唯一入口，接收用户的输入指令，提供认证、授权、API注册和发现等机制
  - `Scheduler`负责集群资源调度，按照一定的调度策略将pod调度到相应的节点
  - `ControllerManager`负责维护集群状态，比如程序部署安排、故障检测、自动扩展、滚动更新等
  - `Etcd`负责存储集群中各种资源对象的信息
- **node(工作节点)：** 集群数据层面，负责为容器提供运行环境
  - `Kubelet`负责维护容器的生命周期，通过控制docker进行创建、更新、销毁容器
  - `KubeProxy`负责提供集群内部的服务发现和负载均衡
  - `Docker`负责节点上容器的各种操作
- **工作概览**
  - 当k8s环境启动后，master和node都会将自身学习存储至etcd数据库中
  - 一个nginx服务的安装请求会首先通过`kubectl`进入到`apoServer`组件中
  - `apiServer`组件会调用`scheduler`组件来决定要将请求发送到哪个node节点中
  - `scheduler`从etcd中读取各个node节点的信息，按照一定算法选取node节点，并将结果返回至`apiServer`
  - `apiServer`调用`controller-manager`去调度Node节点按照nginx服务
  - `kubelet`接收到指令后通知docker，由docker启动一个nginx的pod
  - 其中pod是k8s的最小操作单元，容器必须跑在pod中
  - 至此一个nginx服务就运行了，如果要访问nginx，需要通过`kube-proxy`来对pod产生访问代理，这样外界用户就可以访问到集群中的nginx服务了